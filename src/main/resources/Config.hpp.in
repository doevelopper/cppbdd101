#ifndef @NSPACE@_CONFIG_HPP
#defile @NSPACE@_CONFIG_HPP

#include <type_traits>
#include <cstddef>
#include <utility>

#ifdef __cplusplus
#  if __cplusplus < 201402
#    error requires a C++14 compiler and yours does not seem to be that.
#  endif
#endif

#if defined(__linux__) || defined(__linux) || defined(__MINGW64__)
    #define ABI_OS_LINUX
    #define ABI_OS_LINUX_LIKE
#else
    #error "This OS is not supported "
#endif

#if defined(__GNUC__)
    #define CC_GNU  (__GNUC__ * 100 + __GNUC_MINOR__)
    #define ABI_DECL_DEPRECATED __attribute__ ((__deprecated__))

    #if !defined(ABI_NAMESPACE) 
        #define ABI_PREPEND_NAMESPACE(name) ::name
        #define ABI_USE_NAMESPACE
        #define ABI_BEGIN_NAMESPACE
        #define ABI_END_NAMESPACE
        #define ABI_BEGIN_INCLUDE_NAMESPACE
        #define ABI_END_INCLUDE_NAMESPACE
        #define ABI_FORWARD_DECLARE_CLASS(name) class name;
        #define ABI_FORWARD_DECLARE_STRUCT(name) struct name;
        #define ABI_MANGLE_NAMESPACE(name) name
    #else
        #define ABI_PREPEND_NAMESPACE(name) ::ABI_NAMESPACE::name
        #define ABI_USE_NAMESPACE using namespace ::ABI_NAMESPACE;
        #define ABI_BEGIN_NAMESPACE namespace ABI_NAMESPACE {
        #define ABI_END_NAMESPACE }
        #define ABI_BEGIN_INCLUDE_NAMESPACE }
        #define ABI_END_INCLUDE_NAMESPACE namespace ABI_NAMESPACE {

        #define ABI_FORWARD_DECLARE_CLASS(name) \
            ABI_BEGIN_NAMESPACE class name; ABI_END_NAMESPACE \
            using ABI_PREPEND_NAMESPACE(name);

        #define ABI_FORWARD_DECLARE_STRUCT(name) \
            ABI_BEGIN_NAMESPACE struct name; ABI_END_NAMESPACE \
            using ABI_PREPEND_NAMESPACE(name);

        #define ABI_MANGLE_NAMESPACE0(x) x
        #define ABI_MANGLE_NAMESPACE1(a, b) a##_##b
        #define ABI_MANGLE_NAMESPACE2(a, b) ABI_MANGLE_NAMESPACE1(a,b)
        #define ABI_MANGLE_NAMESPACE(name) ABI_MANGLE_NAMESPACE2( \
            ABI_MANGLE_NAMESPACE0(name), ABI_MANGLE_NAMESPACE0(ABI_NAMESPACE))

        namespace ABI_NAMESPACE
        {
        }

    #endif

    ABI_BEGIN_NAMESPACE

    #if defined(ABI_SHARED) || !defined(ABI_STATIC)

        #ifdef ABI_STATIC
            #error "Both ABI_SHARED and ABI_STATIC defined, please make up your mind"
		#endif

		#ifndef ABI_SHARED
				#define ABI_SHARED
		#endif

		#if defined(ABI_BUILD_LIB)
			#define ABI_CORE_EXPORT ABI_DECL_EXPORT
		#else
			#define ABI_CORE_EXPORT ABI_DECL_IMPORT
		#endif

    #else
		#define ABI_CORE_EXPORT
    #endif

    #if defined(ABI_CC_GNU)
        #define ABI_NEVER_INLINE __attribute__((noinline))
        #define ABI_ALWAYS_INLINE inline __attribute__((always_inline))
    #else
        #define ABI_NEVER_INLINE
        #define ABI_ALWAYS_INLINE inline
    #endif

    #define ABI_UNUSED(x) (void)x;
    #define NOOP(x) do { } while (0) // ((void)0)

    template < typename T > 
    static inline T * ptrHelper (T * ptr)
    {
        return ptr;
    }
    
    ABI_END_NAMESPACE
#else

#endif

    #  ifdef ABI_OS_LINUX
    #    define ABI_DECL_EXPORT         __attribute__((visibility("default")))
    #    define ABI_DECL_IMPORT         __attribute__((visibility("default")))
    #    define ABI_DECL_HIDDEN         __attribute__((visibility("hidden")))
    #  else
    #    define ABI_DECL_EXPORT         __declspec(dllexport)
    #    define ABI_DECL_IMPORT         __declspec(dllimport)
    #    define ABI_DECL_HIDDEN
    #  endif

    #  define ABI_FUNC_INFO             __PRETTY_FUNCTION__
    #  define ABI_DECL_UNUSED           __attribute__((__unused__))
    #  define ABI_NORETURN              __attribute__((__noreturn__))
    #  define ABI_DECL_PURE_FUNCTION    __attribute__((pure))
    #  define ABI_DECL_CONST_FUNCTION   __attribute__((const))
    #  define ABI_PACKED                __attribute__ ((__packed__))
    #  define ABI_UNREACHABLE_IMPL()    __assume(0)
    #  define ABI_NULLPTR         		nullptr
    #  define ABI_DECL_EQ_DEFAULT 		= default
    #  define ABI_DECL_EQ_DELETE 		= delete
	#  define ABI_DECL_OVERRIDE         override
	#  define ABI_DECL_FINAL            final

    #if defined ABI_COMPILER_CONSTEXPR
        # if defined(__cpp_constexpr) && __cpp_constexpr-0 >= 201304
            #  define ABI_DECL_CONSTEXPR constexpr
            #  define ABI_DECL_RELAXED_CONSTEXPR constexpr
            #  define ABI_CONSTEXPR constexpr
            #  define ABI_RELAXED_CONSTEXPR constexpr
        # else
            #  define ABI_DECL_CONSTEXPR constexpr
            #  define ABI_DECL_RELAXED_CONSTEXPR
            #  define ABI_CONSTEXPR constexpr
            #  define ABI_RELAXED_CONSTEXPR const
        # endif
    #else
        # define ABI_DECL_CONSTEXPR
        # define ABI_DECL_RELAXED_CONSTEXPR
        # define ABI_CONSTEXPR const
        # define ABI_RELAXED_CONSTEXPR const
    #endif

    #ifdef ABI_COMPILER_RVALUE_REFS
        #define nsMove(x) std::move(x)
    #else
        #define nsMove(x) (x)
    #endif

    #ifdef ABI_COMPILER_RVALUE_REFS
        #define qMove(x) std::move(x)
    #else
        #define qMove(x) (x)
    #endif

    #define ABI_UNREACHABLE() \
        do {\
            ABI_ASSERT_X(false, "ABI_UNREACHABLE()", "ABI_UNREACHABLE was reached");\
            ABI_UNREACHABLE_IMPL();\
        } while (0)

    #define ABI_ASSUME(Expr) \
        do {\
            const bool valueOfExpression = Expr;\
            ABI_ASSERT_X(valueOfExpression, "ABI_ASSUME()", "Assumption in ABI_ASSUME(\"" #Expr "\") was not correct");\
            ABI_ASSUME_IMPL(valueOfExpression);\
        } while (0)

    #ifndef ABI_FALLTHROUGH
        #  if (defined(ABI_CC_GNU) && ABI_CC_GNU >= 700) && !defined(ABI_CC_INTEL)
            #    define ABI_FALLTHROUGH() __attribute__((fallthrough))
        #  else
            #    define ABI_FALLTHROUGH() (void)0
    #endif

    #if defined(__cplusplus)
        #if HAS_CPP_ATTRIBUTE(fallthrough)
            #  define ABI_FALLTHROUGH() [[fallthrough]]
        #elif HAS_CPP_ATTRIBUTE(clang::fallthrough)
            #    define ABI_FALLTHROUGH() [[clang::fallthrough]]
        #elif HAS_CPP_ATTRIBUTE(gnu::fallthrough)
            #    define ABI_FALLTHROUGH() [[gnu::fallthrough]]
        #endif
    #endif

    template < typename T > 
    static inline T * ptrTypeHelper (T * ptr)
    {
        return ptr;
    }

    template < typename Wrapper > 
    static inline typename  std::shared_ptr
    ptrTypeHelper (const Wrapper & p)
    {
        return p.get ();
    }

    #define ABI_DECLARE_PRIVATE(Class)                                         \
        inline Class##Private* d_func()                                             \
        {                                                                           \
            return reinterpret_cast<Class##Private *>(ptrTypeHelper(d_ptr));        \
        }                                                                           \
        inline const Class##Private* d_func() const                                 \
        {                                                                           \
            return reinterpret_cast<const Class##Private *>(ptrTypeHelper(d_ptr));  \
        }                                                                           \
        friend class Class##Private;

    #define ABI_DECLARE_PRIVATE_D(Dptr, Class)                                 \
        inline Class##Private* d_func()                                             \
        {                                                                           \
            return reinterpret_cast<Class##Private *>(ptrTypeHelper(Dptr));         \
        }                                                                           \
        inline const Class##Private* d_func() const                                 \
        {                                                                           \
            return reinterpret_cast<const Class##Private *>(ptrTypeHelper(Dptr));   \
        }                                                                           \
        friend class Class##Private;

    #define ABI_DECLARE_PUBLIC(Class)                                          \
        inline Class* q_func()                                                      \
        {                                                                           \
            return static_cast<Class *>(q_ptr);                                     \
        }                                                                           \
        inline const Class* q_func() const                                          \
        {                                                                           \
            return static_cast<const Class *>(q_ptr);                               \
        }                                                                           \
        friend class Class;

    #define ABI_DISABLE_COPY(Class)                                            \
        Class(const Class &) ABI_DECL_EQ_DELETE; \
        Class &operator = (const Class &) ABI_DECL_EQ_DELETE;

    // With ABI_D you can use the members of Class##Private from Class
    #define ABI_D(Class) Class##Private * const d = d_func()

    // With ABI_Q you can use the members of Class from Class##Private
    #define ABI_Q(Class) Class * const q = q_func()
/*!
 * How to
 * 

    std::function<void(int)> f1 = noop{};
    f1(3);
    std::function<int(std::string, char, double)> f2 = noop{};
    
    std::function<std::string const&(int)> f3 = noop{};
    
    int x = noop::anything{};
    (void)x;
    int const& y = noop::anything{};
    (void)y;
    
    std::cout << "f3 creates: " << f3(2) << std::endl;
*/
class NoOp 
{
    class anything 
    {
        template<class T>
        operator T()
        { 
            return {}; 
        }

        // optional reference support.  Somewhat evil.
        template<class T>
        operator const T&()const
        { 
            static T t{}; 
            return t; 
        }
    };
	
    template<class...Args>
    anything operator()(Args&&...)const
    {
        return {};
    }
	
    template<class...Args>
    operator std::function<void(Args...)>() 
    {
        return [](auto&&...){};
    }
	
    template <typename RESULT, typename... Args>
    std::function<RESULT(Args...)> getFuncNoOp()
    {
            // && avoids unnecessary copying. Thanks @Yakk
            return [](Args&&...) 
        { 
            return RESULT(); 
        }; 
    }	
};
#endif
